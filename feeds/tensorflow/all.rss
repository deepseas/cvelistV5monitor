<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>CVE Feed for tensorflow -- all</title>
    <link>https://raw.githubusercontent.com/deepseas/cvelistV5monitor/main/feeds/tensorflow/all.rss</link>
    <description>The latest CVEs for tensorflow -- all products</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <lastBuildDate>Sun, 04 Aug 2024 16:23:48 +0000</lastBuildDate>
    <ttl>60</ttl>
    <item>
      <title>CVE-2021-37647|2024-08-04T01:23:01.556Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37647</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. When a user does not supply arguments that determine a valid sparse tensor, `tf.raw_ops.SparseTensorSliceDataset` implementation can be made to dereference a null pointer. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L240-L251) has some argument validation but fails to consider the case when either `indices` or `values` are provided for an empty sparse tensor when the other is not. If `indices` is empty, then [code that performs validation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L260-L261) (i.e., checking that the indices are monotonically increasing) results in a null pointer dereference. If `indices` as provided by the user is empty, then `indices` in the C++ code above is backed by an empty `std::vector`, hence calling `indices-&gt;dim_size(0)` results in null pointer dereferencing (same as calling `std::vector::at()` on an empty vector). We have patched the issue in GitHub commit 02cc160e29d20631de3859c6653184e3f876b9d7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37647|2024-08-04T01:23:01.556Z</guid>
      <pubDate>Thu, 12 Aug 2021 18:10:27 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15265|2024-08-04T13:15:19.748Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15265</link>
      <description>In Tensorflow before version 2.4.0, an attacker can pass an invalid `axis` value to `tf.quantization.quantize_and_dequantize`. This results in accessing a dimension outside the rank of the input tensor in the C++ kernel implementation. However, dim_size only does a DCHECK to validate the argument and then uses it to access the corresponding element of an array. Since in normal builds, `DCHECK`-like macros are no-ops, this results in segfault and access out of bounds of the array. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.</description>
      <guid isPermaLink="false">CVE-2020-15265|2024-08-04T13:15:19.748Z</guid>
      <pubDate>Wed, 21 Oct 2020 20:20:15 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15207|2024-08-04T13:08:22.887Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15207</link>
      <description>In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, to mimic Python's indexing with negative values, TFLite uses `ResolveAxis` to convert negative values to positive indices. However, the only check that the converted index is now valid is only present in debug builds. If the `DCHECK` does not trigger, then code execution moves ahead with a negative index. This, in turn, results in accessing data out of bounds which results in segfaults and/or data corruption. The issue is patched in commit 2d88f470dea2671b430884260f3626b1fe99830a, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15207|2024-08-04T13:08:22.887Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:45:46 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15211|2024-08-04T13:08:22.936Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15211</link>
      <description>In TensorFlow Lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, saved models in the flatbuffer format use a double indexing scheme: a model has a set of subgraphs, each subgraph has a set of operators and each operator has a set of input/output tensors. The flatbuffer format uses indices for the tensors, indexing into an array of tensors that is owned by the subgraph. This results in a pattern of double array indexing when trying to get the data of each tensor. However, some operators can have some tensors be optional. To handle this scenario, the flatbuffer model uses a negative `-1` value as index for these tensors. This results in special casing during validation at model loading time. Unfortunately, this means that the `-1` index is a valid tensor index for any operator, including those that don't expect optional inputs and including for output tensors. Thus, this allows writing and reading from outside the bounds of heap allocated arrays, although only at a specific offset from the start of these arrays. This results in both read and write gadgets, albeit very limited in scope. The issue is patched in several commits (46d5b0852, 00302787b7, e11f5558, cd31fd0ce, 1970c21, and fff2c83), and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that only operators which accept optional inputs use the `-1` special value and only for the tensors that they expect to be optional. Since this allow-list type approach is erro-prone, we advise upgrading to the patched code.</description>
      <guid isPermaLink="false">CVE-2020-15211|2024-08-04T13:08:22.936Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:45:24 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37670|2024-08-04T01:23:01.507Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37670</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.UpperBound`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/searchsorted_op.cc#L85-L104) does not validate the rank of `sorted_input` argument. A similar issue occurs in `tf.raw_ops.LowerBound`. We have patched the issue in GitHub commit 42459e4273c2e47a3232cc16c4f4fff3b3a35c38. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37670|2024-08-04T01:23:01.507Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:25:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41207|2024-08-04T03:08:31.386Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41207</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the implementation of `ParallelConcat` misses some input validation and can produce a division by 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41207|2024-08-04T03:08:31.386Z</guid>
      <pubDate>Fri, 05 Nov 2021 21:50:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37685|2024-08-04T01:23:01.547Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37685</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`expand_dims.cc`](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/expand_dims.cc#L36-L50) contains a vulnerability which allows reading one element outside of bounds of heap allocated data. If `axis` is a large negative value (e.g., `-100000`), then after the first `if` it would still be negative. The check following the `if` statement will pass and the `for` loop would read one element before the start of `input_dims.data` (when `i = 0`). We have patched the issue in GitHub commit d94ffe08a65400f898241c0374e9edc6fa8ed257. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37685|2024-08-04T01:23:01.547Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:15:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37653|2024-08-04T01:23:01.402Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37653</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a floating point exception in `tf.raw_ops.ResourceGather`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L725-L731) computes the value of a value, `batch_size`, and then divides by it without checking that this value is not 0. We have patched the issue in GitHub commit ac117ee8a8ea57b73d34665cdf00ef3303bc0b11. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37653|2024-08-04T01:23:01.402Z</guid>
      <pubDate>Thu, 12 Aug 2021 17:35:22 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15196|2024-08-04T13:08:22.710Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15196</link>
      <description>In Tensorflow version 2.3.0, the `SparseCountSparseOutput` and `RaggedCountSparseOutput` implementations don't validate that the `weights` tensor has the same shape as the data. The check exists for `DenseCountSparseOutput`, where both tensors are fully specified. In the sparse and ragged count weights are still accessed in parallel with the data. But, since there is no validation, a user passing fewer weights than the values for the tensors can generate a read from outside the bounds of the heap buffer allocated for the weights. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15196|2024-08-04T13:08:22.710Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:40:36 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37644|2024-08-04T01:23:01.306Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37644</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions providing a negative element to `num_elements` list argument of `tf.raw_ops.TensorListReserve` causes the runtime to abort the process due to reallocating a `std::vector` to have a negative number of elements. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/list_kernels.cc#L312) calls `std::vector.resize()` with the new size controlled by input given by the user, without checking that this input is valid. We have patched the issue in GitHub commit 8a6e874437670045e6c7dc6154c7412b4a2135e2. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37644|2024-08-04T01:23:01.306Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:35:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37676|2024-08-04T01:23:01.528Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37676</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.SparseFillEmptyRows`. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) does not validate that the input arguments are not empty tensors. We have patched the issue in GitHub commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37676|2024-08-04T01:23:01.528Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:40:27 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37684|2024-08-04T01:23:01.504Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37684</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementations of pooling in TFLite are vulnerable to division by 0 errors as there are no checks for divisors not being 0. We have patched the issue in GitHub commit [dfa22b348b70bb89d6d6ec0ff53973bacb4f4695](https://github.com/tensorflow/tensorflow/commit/dfa22b348b70bb89d6d6ec0ff53973bacb4f4695). The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37684|2024-08-04T01:23:01.504Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:30:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-26271|2024-08-04T15:56:04.342Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-26271</link>
      <description>In affected versions of TensorFlow under certain cases, loading a saved model can result in accessing uninitialized memory while building the computation graph. The MakeEdge function creates an edge between one output tensor of the src node (given by output_index) and the input slot of the dst node (given by input_index). This is only possible if the types of the tensors on both sides coincide, so the function begins by obtaining the corresponding DataType values and comparing these for equality. However, there is no check that the indices point to inside of the arrays they index into. Thus, this can result in accessing data out of bounds of the corresponding heap allocated arrays. In most scenarios, this can manifest as unitialized data access, but if the index points far away from the boundaries of the arrays this can be used to leak addresses from the library. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.</description>
      <guid isPermaLink="false">CVE-2020-26271|2024-08-04T15:56:04.342Z</guid>
      <pubDate>Thu, 10 Dec 2020 22:10:14 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15204|2024-08-04T13:08:22.924Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15204</link>
      <description>In eager mode, TensorFlow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1 does not set the session state. Hence, calling `tf.raw_ops.GetSessionHandle` or `tf.raw_ops.GetSessionHandleV2` results in a null pointer dereference In linked snippet, in eager mode, `ctx-&gt;session_state()` returns `nullptr`. Since code immediately dereferences this, we get a segmentation fault. The issue is patched in commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15204|2024-08-04T13:08:22.924Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:46:02 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37648|2024-08-04T01:23:01.284Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37648</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the code for `tf.raw_ops.SaveV2` does not properly validate the inputs and an attacker can trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) uses `ValidateInputs` to check that the input arguments are valid. This validation would have caught the illegal state represented by the reproducer above. However, the validation uses `OP_REQUIRES` which translates to setting the `Status` object of the current `OpKernelContext` to an error status, followed by an empty `return` statement which just terminates the execution of the function it is present in. However, this does not mean that the kernel execution is finalized: instead, execution continues from the next line in `Compute` that follows the call to `ValidateInputs`. This is equivalent to lacking the validation. We have patched the issue in GitHub commit 9728c60e136912a12d99ca56e106b7cce7af5986. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37648|2024-08-04T01:23:01.284Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:15:18 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41216|2024-08-04T03:08:31.489Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41216</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference function for `Transpose` is vulnerable to a heap buffer overflow. This occurs whenever `perm` contains negative elements. The shape inference function does not validate that the indices in `perm` are all valid. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41216|2024-08-04T03:08:31.489Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:10:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41219|2024-08-04T03:08:31.583Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41219</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the code for sparse matrix multiplication is vulnerable to undefined behavior via binding a reference to `nullptr`. This occurs whenever the dimensions of `a` or `b` are 0 or less. In the case on one of these is 0, an empty output tensor should be allocated (to conserve the invariant that output tensors are always allocated when the operation is successful) but nothing should be written to it (that is, we should return early from the kernel implementation). Otherwise, attempts to write to this empty tensor would result in heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41219|2024-08-04T03:08:31.583Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:50:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37635|2024-08-04T01:23:01.255Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37635</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37635|2024-08-04T01:23:01.255Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:30:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15209|2024-08-04T13:08:22.925Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15209</link>
      <description>In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, a crafted TFLite model can force a node to have as input a tensor backed by a `nullptr` buffer. This can be achieved by changing a buffer index in the flatbuffer serialization to convert a read-only tensor to a read-write one. The runtime assumes that these buffers are written to before a possible read, hence they are initialized with `nullptr`. However, by changing the buffer index for a tensor and implicitly converting that tensor to be a read-write one, as there is nothing in the model that writes to it, we get a null pointer dereference. The issue is patched in commit 0b5662bc, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15209|2024-08-04T13:08:22.925Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:45:35 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41214|2024-08-04T03:08:31.367Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41214</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` has an undefined behavior due to binding a reference to `nullptr`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41214|2024-08-04T03:08:31.367Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:50:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41211|2024-08-04T03:08:31.458Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41211</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `QuantizeV2` can trigger a read outside of bounds of heap allocated array. This occurs whenever `axis` is a negative value less than `-1`. In this case, we are accessing data before the start of a heap buffer. The code allows `axis` to be an optional argument (`s` would contain an `error::NOT_FOUND` error code). Otherwise, it assumes that `axis` is a valid index into the dimensions of the `input` tensor. If `axis` is less than `-1` then this results in a heap OOB read. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.</description>
      <guid isPermaLink="false">CVE-2021-41211|2024-08-04T03:08:31.458Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:15:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37679|2024-08-04T01:23:01.507Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37679</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions it is possible to nest a `tf.map_fn` within another `tf.map_fn` call. However, if the input tensor is a `RaggedTensor` and there is no function signature provided, code assumes the output is a fully specified tensor and fills output buffer with uninitialized contents from the heap. The `t` and `z` outputs should be identical, however this is not the case. The last row of `t` contains data from the heap which can be used to leak other memory information. The bug lies in the conversion from a `Variant` tensor to a `RaggedTensor`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc#L177-L190) does not check that all inner shapes match and this results in the additional dimensions. The same implementation can result in data loss, if input tensor is tweaked. We have patched the issue in GitHub commit 4e2565483d0ffcadc719bd44893fb7f609bb5f12. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37679|2024-08-04T01:23:01.507Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:20:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37651|2024-08-04T01:23:01.436Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37651</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.FractionalAvgPoolGrad` can be tricked into accessing data outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/fractional_avg_pool_op.cc#L205) does not validate that the input tensor is non-empty. Thus, code constructs an empty `EigenDoubleMatrixMap` and then accesses this buffer with indices that are outside of the empty area. We have patched the issue in GitHub commit 0f931751fb20f565c4e94aa6df58d54a003cdb30. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37651|2024-08-04T01:23:01.436Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:00:19 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37667|2024-08-04T01:23:01.485Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37667</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.UnicodeEncode`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unicode_ops.cc#L533-L539) reads the first dimension of the `input_splits` tensor before validating that this tensor is not empty. We have patched the issue in GitHub commit 2e0ee46f1a47675152d3d865797a18358881d7a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37667|2024-08-04T01:23:01.485Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:40:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41197|2024-08-04T03:08:31.502Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41197</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions TensorFlow allows tensor to have a large number of dimensions and each dimension can be as large as desired. However, the total number of elements in a tensor must fit within an `int64_t`. If an overflow occurs, `MultiplyWithoutOverflow` would return a negative result. In the majority of TensorFlow codebase this then results in a `CHECK`-failure. Newer constructs exist which return a `Status` instead of crashing the binary. This is similar to CVE-2021-29584. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41197|2024-08-04T03:08:31.502Z</guid>
      <pubDate>Fri, 05 Nov 2021 19:55:36 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15201|2024-08-04T13:08:22.883Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15201</link>
      <description>In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Hence, the code is prone to heap buffer overflow. If `split_values` does not end with a value at least `num_values` then the `while` loop condition will trigger a read outside of the bounds of `split_values` once `batch_idx` grows too large. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15201|2024-08-04T13:08:22.883Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:46:21 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15210|2024-08-04T13:08:22.871Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15210</link>
      <description>In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, if a TFLite saved model uses the same tensor as both input and output of an operator, then, depending on the operator, we can observe a segmentation fault or just memory corruption. We have patched the issue in d58c96946b and will release patch releases for all versions between 1.15 and 2.3. We recommend users to upgrade to TensorFlow 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15210|2024-08-04T13:08:22.871Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:45:30 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41196|2024-08-04T03:08:31.485Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41196</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the Keras pooling layers can trigger a segfault if the size of the pool is 0 or if a dimension is negative. This is due to the TensorFlow's implementation of pooling operations where the values in the sliding window are not checked to be strictly positive. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41196|2024-08-04T03:08:31.485Z</guid>
      <pubDate>Fri, 05 Nov 2021 19:55:13 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37677|2024-08-04T01:23:01.450Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37677</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the shape inference code for `tf.raw_ops.Dequantize` has a vulnerability that could trigger a denial of service via a segfault if an attacker provides invalid arguments. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/array_ops.cc#L2999-L3014) uses `axis` to select between two different values for `minmax_rank` which is then used to retrieve tensor dimensions. However, code assumes that `axis` can be either `-1` or a value greater than `-1`, with no validation for the other values. We have patched the issue in GitHub commit da857cfa0fde8f79ad0afdbc94e88b5d4bbec764. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37677|2024-08-04T01:23:01.450Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:35:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15192|2024-08-04T13:08:22.666Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15192</link>
      <description>In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes a list of strings to `dlpack.to_dlpack` there is a memory leak following an expected validation failure. The issue occurs because the `status` argument during validation failures is not properly checked. Since each of the above methods can return an error status, the `status` value must be checked before continuing. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15192|2024-08-04T13:08:22.666Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:40:56 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37678|2024-08-04T01:23:01.401Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37678</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions TensorFlow and Keras can be tricked to perform arbitrary code execution when deserializing a Keras model from YAML format. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/python/keras/saving/model_config.py#L66-L104) uses `yaml.unsafe_load` which can perform arbitrary code execution on the input. Given that YAML format support requires a significant amount of work, we have removed it for now. We have patched the issue in GitHub commit 23d6383eb6c14084a8fc3bdf164043b974818012. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37678|2024-08-04T01:23:01.401Z</guid>
      <pubDate>Thu, 12 Aug 2021 23:05:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37690|2024-08-04T01:23:01.511Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37690</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions when running shape functions, some functions (such as `MutableHashTableShape`) produce extra output information in the form of a `ShapeAndType` struct. The shapes embedded in this struct are owned by an inference context that is cleaned up almost immediately; if the upstream code attempts to access this shape information, it can trigger a segfault. `ShapeRefiner` is mitigating this for normal output shapes by cloning them (and thus putting the newly created shape under ownership of an inference context that will not die), but we were not doing the same for shapes and types. This commit fixes that by doing similar logic on output shapes and types. We have patched the issue in GitHub commit ee119d4a498979525046fba1c3dd3f13a039fbb1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37690|2024-08-04T01:23:01.511Z</guid>
      <pubDate>Thu, 12 Aug 2021 23:10:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37649|2024-08-04T01:23:01.296Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37649</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. The code for `tf.raw_ops.UncompressElement` can be made to trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/compression_ops.cc#L50-L53) obtains a pointer to a `CompressedElement` from a `Variant` tensor and then proceeds to dereference it for decompressing. There is no check that the `Variant` tensor contained a `CompressedElement`, so the pointer is actually `nullptr`. We have patched the issue in GitHub commit 7bdf50bb4f5c54a4997c379092888546c97c3ebd. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37649|2024-08-04T01:23:01.296Z</guid>
      <pubDate>Thu, 12 Aug 2021 18:10:32 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41202|2024-08-04T03:08:31.442Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41202</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions while calculating the size of the output within the `tf.range` kernel, there is a conditional statement of type `int64 = condition ? int64 : double`. Due to C++ implicit conversion rules, both branches of the condition will be cast to `double` and the result would be truncated before the assignment. This result in overflows. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41202|2024-08-04T03:08:31.442Z</guid>
      <pubDate>Fri, 05 Nov 2021 21:45:18 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37681|2024-08-04T01:23:01.508Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37681</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of SVDF in TFLite is [vulnerable to a null pointer error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). The [`GetVariableInput` function](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) can return a null pointer but `GetTensorData` assumes that the argument is always a valid tensor. Furthermore, because `GetVariableInput` calls [`GetMutableInput`](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) which might return `nullptr`, the `tensor-&gt;is_variable` expression can also trigger a null pointer exception. We have patched the issue in GitHub commit 5b048e87e4e55990dae6b547add4dae59f4e1c76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37681|2024-08-04T01:23:01.508Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:00:24 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37669|2024-08-04T01:23:01.462Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37669</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.NonMaxSuppressionV5` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/image/non_max_suppression_op.cc#L170-L271) uses a user controlled argument to resize a `std::vector`. However, as `std::vector::resize` takes the size argument as a `size_t` and `output_size` is an `int`, there is an implicit conversion to unsigned. If the attacker supplies a negative value, this conversion results in a crash. A similar issue occurs in `CombinedNonMaxSuppression`. We have patched the issue in GitHub commit 3a7362750d5c372420aa8f0caf7bf5b5c3d0f52d and commit [b5cdbf12ffcaaffecf98f22a6be5a64bb96e4f58. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37669|2024-08-04T01:23:01.462Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:55:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-26270|2024-08-04T15:56:03.807Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-26270</link>
      <description>In affected versions of TensorFlow running an LSTM/GRU model where the LSTM/GRU layer receives an input with zero-length results in a CHECK failure when using the CUDA backend. This can result in a query-of-death vulnerability, via denial of service, if users can control the input to the layer. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.</description>
      <guid isPermaLink="false">CVE-2020-26270|2024-08-04T15:56:03.807Z</guid>
      <pubDate>Thu, 10 Dec 2020 22:10:23 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37687|2024-08-04T01:23:01.653Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37687</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`GatherNd` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather_nd.cc#L124) does not support negative indices but there are no checks for this situation. Hence, an attacker can read arbitrary data from the heap by carefully crafting a model with negative values in `indices`. Similar issue exists in [`Gather` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather.cc). We have patched the issue in GitHub commits bb6a0383ed553c286f87ca88c207f6774d5c4a8f and eb921122119a6b6e470ee98b89e65d721663179d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37687|2024-08-04T01:23:01.653Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:15:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37658|2024-08-04T01:23:01.440Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37658</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixSetDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit ff8894044dfae5568ecbf2ed514c1a37dc394f1b. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37658|2024-08-04T01:23:01.440Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:50:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41228|2024-08-04T03:08:31.343Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41228</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's `saved_model_cli` tool is vulnerable to a code injection as it calls `eval` on user supplied strings. This can be used by attackers to run arbitrary code on the plaform where the CLI tool runs. However, given that the tool is always run manually, the impact of this is not severe. We have patched this by adding a `safe` flag which defaults to `True` and an explicit warning for users. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41228|2024-08-04T03:08:31.343Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:25:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37672|2024-08-04T01:23:01.434Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37672</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.SdcaOptimizerV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/sdca_internal.cc#L320-L353) does not check that the length of `example_labels` is the same as the number of examples. We have patched the issue in GitHub commit a4e138660270e7599793fa438cd7b2fc2ce215a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37672|2024-08-04T01:23:01.434Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:20:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15190|2024-08-04T13:08:22.683Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15190</link>
      <description>In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `tf.raw_ops.Switch` operation takes as input a tensor and a boolean and outputs two tensors. Depending on the boolean value, one of the tensors is exactly the input tensor whereas the other one should be an empty tensor. However, the eager runtime traverses all tensors in the output. Since only one of the tensors is defined, the other one is `nullptr`, hence we are binding a reference to `nullptr`. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. In this case, this results in a segmentation fault The issue is patched in commit da8558533d925694483d2c136a9220d6d49d843c, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15190|2024-08-04T13:08:22.683Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:35:13 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41218|2024-08-04T03:08:31.519Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41218</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `AllToAll` can be made to execute a division by 0. This occurs whenever the `split_count` argument is 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41218|2024-08-04T03:08:31.519Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:05:20 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15198|2024-08-04T13:08:22.711Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15198</link>
      <description>In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has the same shape as the `values` one. The values in these tensors are always accessed in parallel. Thus, a shape mismatch can result in accesses outside the bounds of heap allocated buffers. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15198|2024-08-04T13:08:22.711Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:40:25 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37688|2024-08-04T01:23:01.508Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37688</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L268-L285) unconditionally dereferences a pointer. We have patched the issue in GitHub commit 15691e456c7dc9bd6be203b09765b063bf4a380c. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37688|2024-08-04T01:23:01.508Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:00:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37660|2024-08-04T01:23:01.434Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37660</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a floating point exception by calling inplace operations with crafted arguments that would result in a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/inplace_ops.cc#L283) has a logic error: it should skip processing if `x` and `v` are empty but the code uses `||` instead of `&amp;&amp;`. We have patched the issue in GitHub commit e86605c0a336c088b638da02135ea6f9f6753618. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37660|2024-08-04T01:23:01.434Z</guid>
      <pubDate>Thu, 12 Aug 2021 17:35:27 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37680|2024-08-04T01:23:01.555Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37680</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of fully connected layers in TFLite is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/fully_connected.cc#L226). We have patched the issue in GitHub commit 718721986aa137691ee23f03638867151f74935f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37680|2024-08-04T01:23:01.555Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:45:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15193|2024-08-04T13:08:22.677Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15193</link>
      <description>In Tensorflow before versions 2.2.1 and 2.3.1, the implementation of `dlpack.to_dlpack` can be made to use uninitialized memory resulting in further memory corruption. This is because the pybind11 glue code assumes that the argument is a tensor. However, there is nothing stopping users from passing in a Python object instead of a tensor. The uninitialized memory address is due to a `reinterpret_cast` Since the `PyObject` is a Python object, not a TensorFlow Tensor, the cast to `EagerTensor` fails. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15193|2024-08-04T13:08:22.677Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:40:51 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15199|2024-08-04T13:08:22.934Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15199</link>
      <description>In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the `splits` tensor has the minimum required number of elements. Code uses this quantity to initialize a different data structure. Since `BatchedMap` is equivalent to a vector, it needs to have at least one element to not be `nullptr`. If user passes a `splits` tensor that is empty or has exactly one element, we get a `SIGABRT` signal raised by the operating system. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15199|2024-08-04T13:08:22.934Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:40:20 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37686|2024-08-04T01:23:01.523Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37686</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the strided slice implementation in TFLite has a logic bug which can allow an attacker to trigger an infinite loop. This arises from newly introduced support for [ellipsis in axis definition](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/strided_slice.cc#L103-L122). An attacker can craft a model such that `ellipsis_end_idx` is smaller than `i` (e.g., always negative). In this case, the inner loop does not increase `i` and the `continue` statement causes execution to skip over the preincrement at the end of the outer loop. We have patched the issue in GitHub commit dfa22b348b70bb89d6d6ec0ff53973bacb4f4695. TensorFlow 2.6.0 is the only affected version.</description>
      <guid isPermaLink="false">CVE-2021-37686|2024-08-04T01:23:01.523Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:55:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41205|2024-08-04T03:08:31.437Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41205</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for the `QuantizeAndDequantizeV*` operations can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41205|2024-08-04T03:08:31.437Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:10:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37662|2024-08-04T01:23:01.444Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37662</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can generate undefined behavior via a reference binding to nullptr in `BoostedTreesCalculateBestGainsPerFeature` and similar attack can occur in `BoostedTreesCalculateBestFeatureSplitV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) does not validate the input values. We have patched the issue in GitHub commit 9c87c32c710d0b5b53dc6fd3bfde4046e1f7a5ad and in commit 429f009d2b2c09028647dd4bb7b3f6f414bbaad7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37662|2024-08-04T01:23:01.444Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:55:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37638|2024-08-04T01:23:01.371Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37638</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. Sending invalid argument for `row_partition_types` of `tf.raw_ops.RaggedTensorToTensor` API results in a null pointer dereference and undefined behavior. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L328) accesses the first element of a user supplied list of values without validating that the provided list is not empty. We have patched the issue in GitHub commit 301ae88b331d37a2a16159b65b255f4f9eb39314. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37638|2024-08-04T01:23:01.371Z</guid>
      <pubDate>Thu, 12 Aug 2021 18:10:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15205|2024-08-04T13:08:22.698Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15205</link>
      <description>In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `data_splits` argument of `tf.raw_ops.StringNGrams` lacks validation. This allows a user to pass values that can cause heap overflow errors and even leak contents of memory In the linked code snippet, all the binary strings after `ee ff` are contents from the memory stack. Since these can contain return addresses, this data leak can be used to defeat ASLR. The issue is patched in commit 0462de5b544ed4731aa2fb23946ac22c01856b80, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15205|2024-08-04T13:08:22.698Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:45:57 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41213|2024-08-04T03:08:31.502Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41213</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the code behind `tf.function` API can be made to deadlock when two `tf.function` decorated Python functions are mutually recursive. This occurs due to using a non-reentrant `Lock` Python object. Loading any model which contains mutually recursive functions is vulnerable. An attacker can cause denial of service by causing users to load such models and calling a recursive `tf.function`, although this is not a frequent scenario. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41213|2024-08-04T03:08:31.502Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:10:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-26267|2024-08-04T15:56:04.539Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-26267</link>
      <description>In affected versions of TensorFlow the tf.raw_ops.DataFormatVecPermute API does not validate the src_format and dst_format attributes. The code assumes that these two arguments define a permutation of NHWC. This can result in uninitialized memory accesses, read outside of bounds and even crashes. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.</description>
      <guid isPermaLink="false">CVE-2020-26267|2024-08-04T15:56:04.539Z</guid>
      <pubDate>Thu, 10 Dec 2020 22:10:40 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15194|2024-08-04T13:08:22.713Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15194</link>
      <description>In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1."</description>
      <guid isPermaLink="false">CVE-2020-15194|2024-08-04T13:08:22.713Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:40:46 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-26269|2024-08-04T15:56:04.075Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-26269</link>
      <description>In TensorFlow release candidate versions 2.4.0rc*, the general implementation for matching filesystem paths to globbing pattern is vulnerable to an access out of bounds of the array holding the directories. There are multiple invariants and preconditions that are assumed by the parallel implementation of GetMatchingPaths but are not verified by the PRs introducing it (#40861 and #44310). Thus, we are completely rewriting the implementation to fully specify and validate these. This is patched in version 2.4.0. This issue only impacts master branch and the release candidates for TF version 2.4. The final release of the 2.4 release will be patched.</description>
      <guid isPermaLink="false">CVE-2020-26269|2024-08-04T15:56:04.075Z</guid>
      <pubDate>Thu, 10 Dec 2020 22:10:28 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37668|2024-08-04T01:23:01.519Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37668</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.UnravelIndex` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unravel_index_op.cc#L36) does not check that the tensor subsumed by `dims` is not empty. Hence, if one element of `dims` is 0, the implementation does a division by 0. We have patched the issue in GitHub commit a776040a5e7ebf76eeb7eb923bf1ae417dd4d233. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37668|2024-08-04T01:23:01.519Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:30:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15202|2024-08-04T13:08:22.926Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15202</link>
      <description>In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `Shard` API in TensorFlow expects the last argument to be a function taking two `int64` (i.e., `long long`) arguments. However, there are several places in TensorFlow where a lambda taking `int` or `int32` arguments is being used. In these cases, if the amount of work to be parallelized is large enough, integer truncation occurs. Depending on how the two arguments of the lambda are used, this can result in segfaults, read/write outside of heap allocated arrays, stack overflows, or data corruption. The issue is patched in commits 27b417360cbd671ef55915e4bb6bb06af8b8a832 and ca8c013b5e97b1373b3bb1c97ea655e69f31a575, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15202|2024-08-04T13:08:22.926Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:46:15 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15266|2024-08-04T13:15:18.938Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15266</link>
      <description>In Tensorflow before version 2.4.0, when the `boxes` argument of `tf.image.crop_and_resize` has a very large value, the CPU kernel implementation receives it as a C++ `nan` floating point value. Attempting to operate on this is undefined behavior which later produces a segmentation fault. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.</description>
      <guid isPermaLink="false">CVE-2020-15266|2024-08-04T13:15:18.938Z</guid>
      <pubDate>Wed, 21 Oct 2020 20:30:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15208|2024-08-04T13:08:22.832Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15208</link>
      <description>In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, when determining the common dimension size of two tensors, TFLite uses a `DCHECK` which is no-op outside of debug compilation modes. Since the function always returns the dimension of the first tensor, malicious attackers can craft cases where this is larger than that of the second tensor. In turn, this would result in reads/writes outside of bounds since the interpreter will wrongly assume that there is enough data in both tensors. The issue is patched in commit 8ee24e7949a203d234489f9da2c5bf45a7d5157d, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15208|2024-08-04T13:08:22.832Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:45:40 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37646|2024-08-04T01:23:01.254Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37646</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.StringNGrams` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/string_ngrams_op.cc#L184) calls `reserve` on a `tstring` with a value that sometimes can be negative if user supplies negative `ngram_widths`. The `reserve` method calls `TF_TString_Reserve` which has an `unsigned long` argument for the size of the buffer. Hence, the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit c283e542a3f422420cfdb332414543b62fc4e4a5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37646|2024-08-04T01:23:01.254Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:10:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37650|2024-08-04T01:23:01.462Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37650</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37650|2024-08-04T01:23:01.462Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:00:13 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37683|2024-08-04T01:23:01.436Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37683</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of division in TFLite is [vulnerable to a division by 0 error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/div.cc). There is no check that the divisor tensor does not contain zero elements. We have patched the issue in GitHub commit 1e206baedf8bef0334cca3eb92bab134ef525a28. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37683|2024-08-04T01:23:01.436Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:30:23 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37640|2024-08-04T01:23:01.525Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37640</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseReshape` can be made to trigger an integral division by 0 exception. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L176-L181) calls the reshaping functor whenever there is at least an index in the input but does not check that shape of the input or the target shape have both a non-zero number of elements. The [reshape functor](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L40-L78) blindly divides by the dimensions of the target shape. Hence, if this is not checked, code will result in a division by 0. We have patched the issue in GitHub commit 4923de56ec94fff7770df259ab7f2288a74feb41. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1 as this is the other affected version.</description>
      <guid isPermaLink="false">CVE-2021-37640|2024-08-04T01:23:01.525Z</guid>
      <pubDate>Thu, 12 Aug 2021 17:35:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37692|2024-08-04T01:23:01.419Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37692</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions under certain conditions, Go code can trigger a segfault in string deallocation. For string tensors, `C.TF_TString_Dealloc` is called during garbage collection within a finalizer function. However, tensor structure isn't checked until encoding to avoid a performance penalty. The current method for dealloc assumes that encoding succeeded, but segfaults when a string tensor is garbage collected whose encoding failed (e.g., due to mismatched dimensions). To fix this, the call to set the finalizer function is deferred until `NewTensor` returns and, if encoding failed for a string tensor, deallocs are determined based on bytes written. We have patched the issue in GitHub commit 8721ba96e5760c229217b594f6d2ba332beedf22. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, which is the other affected version.</description>
      <guid isPermaLink="false">CVE-2021-37692|2024-08-04T01:23:01.419Z</guid>
      <pubDate>Thu, 12 Aug 2021 23:00:14 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37641|2024-08-04T01:23:01.426Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37641</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions if the arguments to `tf.raw_ops.RaggedGather` don't determine a valid ragged tensor code can trigger a read from outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/ragged_gather_op.cc#L70) directly reads the first dimension of a tensor shape before checking that said tensor has rank of at least 1 (i.e., it is not a scalar). Furthermore, the implementation does not check that the list given by `params_nested_splits` is not an empty list of tensors. We have patched the issue in GitHub commit a2b743f6017d7b97af1fe49087ae15f0ac634373. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37641|2024-08-04T01:23:01.426Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:30:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41217|2024-08-04T03:08:31.448Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41217</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the process of building the control flow graph for a TensorFlow model is vulnerable to a null pointer exception when nodes that should be paired are not. This occurs because the code assumes that the first node in the pairing (e.g., an `Enter` node) always exists when encountering the second node (e.g., an `Exit` node). When this is not the case, `parent` is `nullptr` so dereferencing it causes a crash. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41217|2024-08-04T03:08:31.448Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:55:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37674|2024-08-04T01:23:01.520Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37674</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37674|2024-08-04T01:23:01.520Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:40:19 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-26268|2024-08-04T15:56:03.596Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-26268</link>
      <description>In affected versions of TensorFlow the tf.raw_ops.ImmutableConst operation returns a constant tensor created from a memory mapped file which is assumed immutable. However, if the type of the tensor is not an integral type, the operation crashes the Python interpreter as it tries to write to the memory area. If the file is too small, TensorFlow properly returns an error as the memory area has fewer bytes than what is needed for the tensor it creates. However, as soon as there are enough bytes, the above snippet causes a segmentation fault. This is because the allocator used to return the buffer data is not marked as returning an opaque handle since the needed virtual method is not overridden. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.</description>
      <guid isPermaLink="false">CVE-2020-26268|2024-08-04T15:56:03.596Z</guid>
      <pubDate>Thu, 10 Dec 2020 22:10:35 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37675|2024-08-04T01:23:01.430Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37675</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions most implementations of convolution operators in TensorFlow are affected by a division by 0 vulnerability where an attacker can trigger a denial of service via a crash. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/framework/common_shape_fns.cc#L577) is missing several validations before doing divisions and modulo operations. We have patched the issue in GitHub commit 8a793b5d7f59e37ac7f3cd0954a750a2fe76bad4. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37675|2024-08-04T01:23:01.430Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:45:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15197|2024-08-04T13:08:22.735Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15197</link>
      <description>In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has rank 2. This tensor must be a matrix because code assumes its elements are accessed as elements of a matrix. However, malicious users can pass in tensors of different rank, resulting in a `CHECK` assertion failure and a crash. This can be used to cause denial of service in serving installations, if users are allowed to control the components of the input sparse tensor. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15197|2024-08-04T13:08:22.735Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:40:31 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37663|2024-08-04T01:23:01.403Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37663</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37663|2024-08-04T01:23:01.403Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:45:18 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41224|2024-08-04T03:08:31.580Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41224</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseFillEmptyRows` can be made to trigger a heap OOB access. This occurs whenever the size of `indices` does not match the size of `values`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41224|2024-08-04T03:08:31.580Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:20:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37639|2024-08-04T01:23:01.249Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37639</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37639|2024-08-04T01:23:01.249Z</guid>
      <pubDate>Thu, 12 Aug 2021 18:10:15 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37654|2024-08-04T01:23:01.509Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37654</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a `CHECK`-fail in debug builds of TensorFlow using `tf.raw_ops.ResourceGather` or a read from outside the bounds of heap allocated data in the same API in a release build. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L660-L668) does not check that the `batch_dims` value that the user supplies is less than the rank of the input tensor. Since the implementation uses several for loops over the dimensions of `tensor`, this results in reading data from outside the bounds of heap allocated buffer backing the tensor. We have patched the issue in GitHub commit bc9c546ce7015c57c2f15c168b3d9201de679a1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37654|2024-08-04T01:23:01.509Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:30:23 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41195|2024-08-04T03:08:31.297Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41195</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the implementation of `tf.math.segment_*` operations results in a `CHECK`-fail related abort (and denial of service) if a segment id in `segment_ids` is large. This is similar to CVE-2021-29584 (and similar other reported vulnerabilities in TensorFlow, localized to specific APIs): the implementation (both on CPU and GPU) computes the output shape using `AddDim`. However, if the number of elements in the tensor overflows an `int64_t` value, `AddDim` results in a `CHECK` failure which provokes a `std::abort`. Instead, code should use `AddDimWithStatus`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41195|2024-08-04T03:08:31.297Z</guid>
      <pubDate>Fri, 05 Nov 2021 19:50:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-26266|2024-08-04T15:56:04.617Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-26266</link>
      <description>In affected versions of TensorFlow under certain cases a saved model can trigger use of uninitialized values during code execution. This is caused by having tensor buffers be filled with the default value of the type but forgetting to default initialize the quantized floating point types in Eigen. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.</description>
      <guid isPermaLink="false">CVE-2020-26266|2024-08-04T15:56:04.617Z</guid>
      <pubDate>Thu, 10 Dec 2020 22:10:47 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41199|2024-08-04T03:08:31.400Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41199</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions if `tf.image.resize` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41199|2024-08-04T03:08:31.400Z</guid>
      <pubDate>Fri, 05 Nov 2021 19:55:19 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37637|2024-08-04T01:23:01.356Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37637</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. It is possible to trigger a null pointer dereference in TensorFlow by passing an invalid input to `tf.raw_ops.CompressElement`. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/data/compression_utils.cc#L34) was accessing the size of a buffer obtained from the return of a separate function call before validating that said buffer is valid. We have patched the issue in GitHub commit 5dc7f6981fdaf74c8c5be41f393df705841fb7c5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37637|2024-08-04T01:23:01.356Z</guid>
      <pubDate>Thu, 12 Aug 2021 18:15:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37657|2024-08-04T01:23:01.539Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37657</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit f2a673bd34f0d64b8e40a551ac78989d16daad09. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37657|2024-08-04T01:23:01.539Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:50:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41227|2024-08-04T03:08:31.590Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41227</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the `ImmutableConst` operation in TensorFlow can be tricked into reading arbitrary memory contents. This is because the `tstring` TensorFlow string class has a special case for memory mapped strings but the operation itself does not offer any support for this datatype. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41227|2024-08-04T03:08:31.590Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:30:23 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37691|2024-08-04T01:23:01.519Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37691</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a division by zero error in LSH [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/lsh_projection.cc#L118). We have patched the issue in GitHub commit 0575b640091680cfb70f4dd93e70658de43b94f9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick thiscommit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37691|2024-08-04T01:23:01.519Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:25:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37666|2024-08-04T01:23:01.509Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37666</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToVariant`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L129) has an incomplete validation of the splits values, missing the case when the argument would be empty. We have patched the issue in GitHub commit be7a4de6adfbd303ce08be4332554dff70362612. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37666|2024-08-04T01:23:01.509Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:40:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15195|2024-08-04T13:08:22.718Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15195</link>
      <description>In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the implementation of `SparseFillEmptyRowsGrad` uses a double indexing pattern. It is possible for `reverse_index_map(i)` to be an index outside of bounds of `grad_values`, thus resulting in a heap buffer overflow. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15195|2024-08-04T13:08:22.718Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:40:41 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41221|2024-08-04T03:08:31.404Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41221</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for the `Cudnn*` operations in TensorFlow can be tricked into accessing invalid memory, via a heap buffer overflow. This occurs because the ranks of the `input`, `input_h` and `input_c` parameters are not validated, but code assumes they have certain values. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41221|2024-08-04T03:08:31.404Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:15:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41206|2024-08-04T03:08:31.625Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41206</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41206|2024-08-04T03:08:31.625Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:05:14 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41208|2024-08-04T03:08:31.577Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41208</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41208|2024-08-04T03:08:31.577Z</guid>
      <pubDate>Fri, 05 Nov 2021 21:50:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15200|2024-08-04T13:08:22.775Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15200</link>
      <description>In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Thus, the code sets up conditions to cause a heap buffer overflow. A `BatchedMap` is equivalent to a vector where each element is a hashmap. However, if the first element of `splits_values` is not 0, `batch_idx` will never be 1, hence there will be no hashmap at index 0 in `per_batch_counts`. Trying to access that in the user code results in a segmentation fault. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15200|2024-08-04T13:08:22.775Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:40:15 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41201|2024-08-04T03:08:31.506Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41201</link>
      <description>TensorFlow is an open source platform for machine learning. In affeced versions during execution, `EinsumHelper::ParseEquation()` is supposed to set the flags in `input_has_ellipsis` vector and `*output_has_ellipsis` boolean to indicate whether there is ellipsis in the corresponding inputs and output. However, the code only changes these flags to `true` and never assigns `false`. This results in unitialized variable access if callers assume that `EinsumHelper::ParseEquation()` always sets these flags. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41201|2024-08-04T03:08:31.506Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:05:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15214|2024-08-04T13:08:22.895Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15214</link>
      <description>In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a write out bounds / segmentation fault if the segment ids are not sorted. Code assumes that the segment ids are in increasing order, using the last element of the tensor holding them to determine the dimensionality of output tensor. This results in allocating insufficient memory for the output tensor and in a write outside the bounds of the output array. This usually results in a segmentation fault, but depending on runtime conditions it can provide for a write gadget to be used in future memory corruption-based exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are sorted, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.</description>
      <guid isPermaLink="false">CVE-2020-15214|2024-08-04T13:08:22.895Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:50:23 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41204|2024-08-04T03:08:31.488Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41204</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions during TensorFlow's Grappler optimizer phase, constant folding might attempt to deep copy a resource tensor. This results in a segfault, as these tensors are supposed to not change. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41204|2024-08-04T03:08:31.488Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:45:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37665|2024-08-04T01:23:01.435Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37665</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37665|2024-08-04T01:23:01.435Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:40:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41210|2024-08-04T03:08:31.472Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41210</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for `SparseCountSparseOutput` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41210|2024-08-04T03:08:31.472Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:10:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37655|2024-08-04T01:23:01.505Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37655</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a read from outside of bounds of heap allocated data by sending invalid arguments to `tf.raw_ops.ResourceScatterUpdate`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L919-L923) has an incomplete validation of the relationship between the shapes of `indices` and `updates`: instead of checking that the shape of `indices` is a prefix of the shape of `updates` (so that broadcasting can happen), code only checks that the number of elements in these two tensors are in a divisibility relationship. We have patched the issue in GitHub commit 01cff3f986259d661103412a20745928c727326f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37655|2024-08-04T01:23:01.505Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:25:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41215|2024-08-04T03:08:31.507Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41215</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `DeserializeSparse` can trigger a null pointer dereference. This is because the shape inference function assumes that the `serialize_sparse` tensor is a tensor with positive rank (and having `3` as the last dimension). The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41215|2024-08-04T03:08:31.507Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:55:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41220|2024-08-04T03:08:31.404Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41220</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the async implementation of `CollectiveReduceV2` suffers from a memory leak and a use after free. This occurs due to the asynchronous computation and the fact that objects that have been `std::move()`d from are still accessed. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.</description>
      <guid isPermaLink="false">CVE-2021-41220|2024-08-04T03:08:31.404Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:20:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41225|2024-08-04T03:08:31.609Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41225</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's Grappler optimizer has a use of unitialized variable. If the `train_nodes` vector (obtained from the saved model that gets optimized) does not contain a `Dequeue` node, then `dequeue_node` is left unitialized. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41225|2024-08-04T03:08:31.609Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:30:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41223|2024-08-04T03:08:31.474Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41223</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the implementation of `FusedBatchNorm` kernels is vulnerable to a heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41223|2024-08-04T03:08:31.474Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:20:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15203|2024-08-04T13:08:22.972Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15203</link>
      <description>In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, by controlling the `fill` argument of tf.strings.as_string, a malicious attacker is able to trigger a format string vulnerability due to the way the internal format use in a `printf` call is constructed. This may result in segmentation fault. The issue is patched in commit 33be22c65d86256e6826666662e40dbdfe70ee83, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15203|2024-08-04T13:08:22.972Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:46:08 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41200|2024-08-04T03:08:31.607Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41200</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions if `tf.summary.create_file_writer` is called with non-scalar arguments code crashes due to a `CHECK`-fail. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41200|2024-08-04T03:08:31.607Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:00:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37656|2024-08-04T01:23:01.518Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37656</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToSparse`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/ragged_tensor_to_sparse_kernel.cc#L30) has an incomplete validation of the splits values: it does not check that they are in increasing order. We have patched the issue in GitHub commit 1071f554dbd09f7e101324d366eec5f4fe5a3ece. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37656|2024-08-04T01:23:01.518Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:50:22 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15206|2024-08-04T13:08:22.955Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15206</link>
      <description>In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, changing the TensorFlow's `SavedModel` protocol buffer and altering the name of required keys results in segfaults and data corruption while loading the model. This can cause a denial of service in products using `tensorflow-serving` or other inference-as-a-service installments. Fixed were added in commits f760f88b4267d981e13f4b302c437ae800445968 and fcfef195637c6e365577829c4d67681695956e7d (both going into TensorFlow 2.2.0 and 2.3.0 but not yet backported to earlier versions). However, this was not enough, as #41097 reports a different failure mode. The issue is patched in commit adf095206f25471e864a8e63a0f1caef53a0e3a6, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15206|2024-08-04T13:08:22.955Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:45:51 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15213|2024-08-04T13:08:22.853Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15213</link>
      <description>In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a denial of service by causing an out of memory allocation in the implementation of segment sum. Since code uses the last element of the tensor holding them to determine the dimensionality of output tensor, attackers can use a very large value to trigger a large allocation. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to limit the maximum value in the segment ids tensor. This only handles the case when the segment ids are stored statically in the model, but a similar validation could be done if the segment ids are generated at runtime, between inference steps. However, if the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.</description>
      <guid isPermaLink="false">CVE-2020-15213|2024-08-04T13:08:22.853Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:50:29 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37671|2024-08-04T01:23:01.520Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37671</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.Map*` and `tf.raw_ops.OrderedMap*` operations. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L222-L248) has a check in place to ensure that `indices` is in ascending order, but does not check that `indices` is not empty. We have patched the issue in GitHub commit 532f5c5a547126c634fefd43bbad1dc6417678ac. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37671|2024-08-04T01:23:01.520Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:40:22 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37652|2024-08-04T01:23:01.506Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37652</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37652|2024-08-04T01:23:01.506Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:15:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-5215|2024-08-04T08:22:09.071Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-5215</link>
      <description>In TensorFlow before 1.15.2 and 2.0.1, converting a string (from Python) to a tf.float16 value results in a segmentation fault in eager mode as the format checks for this use case are only in the graph mode. This issue can lead to denial of service in inference/training where a malicious attacker can send a data point which contains a string instead of a tf.float16 value. Similar effects can be obtained by manipulating saved models and checkpoints whereby replacing a scalar tf.float16 value with a scalar string will trigger this issue due to automatic conversions. This can be easily reproduced by tf.constant("hello", tf.float16), if eager execution is enabled. This issue is patched in TensorFlow 1.15.1 and 2.0.1 with this vulnerability patched. TensorFlow 2.1.0 was released after we fixed the issue, thus it is not affected. Users are encouraged to switch to TensorFlow 1.15.1, 2.0.1 or 2.1.0.</description>
      <guid isPermaLink="false">CVE-2020-5215|2024-08-04T08:22:09.071Z</guid>
      <pubDate>Tue, 28 Jan 2020 21:20:15 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41198|2024-08-04T03:08:31.248Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41198</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions if `tf.tile` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41198|2024-08-04T03:08:31.248Z</guid>
      <pubDate>Fri, 05 Nov 2021 19:55:26 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15212|2024-08-04T13:08:22.919Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15212</link>
      <description>In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger writes outside of bounds of heap allocated buffers by inserting negative elements in the segment ids tensor. Users having access to `segment_ids_data` can alter `output_index` and then write to outside of `output_data` buffer. This might result in a segmentation fault but it can also be used to further corrupt the memory and can be chained with other vulnerabilities to create more advanced exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are all positive, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.</description>
      <guid isPermaLink="false">CVE-2020-15212|2024-08-04T13:08:22.919Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:50:34 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37642|2024-08-04T01:23:01.345Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37642</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37642|2024-08-04T01:23:01.345Z</guid>
      <pubDate>Thu, 12 Aug 2021 17:35:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2020-15191|2024-08-04T13:08:22.683Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2020-15191</link>
      <description>In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes an invalid argument to `dlpack.to_dlpack` the expected validations will cause variables to bind to `nullptr` while setting a `status` variable to the error condition. However, this `status` argument is not properly checked. Hence, code following these methods will bind references to null pointers. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.</description>
      <guid isPermaLink="false">CVE-2020-15191|2024-08-04T13:08:22.683Z</guid>
      <pubDate>Fri, 25 Sep 2020 18:41:01 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37661|2024-08-04T01:23:01.463Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37661</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a denial of service in `boosted_trees_create_quantile_stream_resource` by using negative arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantile_ops.cc#L96) does not validate that `num_streams` only contains non-negative numbers. In turn, [this results in using this value to allocate memory](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantiles/quantile_stream_resource.h#L31-L40). However, `reserve` receives an unsigned integer so there is an implicit conversion from a negative value to a large positive unsigned. This results in a crash from the standard library. We have patched the issue in GitHub commit 8a84f7a2b5a2b27ecf88d25bad9ac777cd2f7992. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37661|2024-08-04T01:23:01.463Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:05:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37689|2024-08-04T01:23:01.451Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37689</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. This is caused by the MLIR optimization of `L2NormalizeReduceAxis` operator. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/compiler/mlir/lite/transforms/optimize.cc#L67-L70) unconditionally dereferences a pointer to an iterator to a vector without checking that the vector has elements. We have patched the issue in GitHub commit d6b57f461b39fd1aa8c1b870f1b974aac3554955. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37689|2024-08-04T01:23:01.451Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:00:19 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41203|2024-08-04T03:08:31.436Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41203</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions an attacker can trigger undefined behavior, integer overflows, segfaults and `CHECK`-fail crashes if they can change saved checkpoints from outside of TensorFlow. This is because the checkpoints loading infrastructure is missing validation for invalid file formats. The fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41203|2024-08-04T03:08:31.436Z</guid>
      <pubDate>Fri, 05 Nov 2021 21:05:13 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41209|2024-08-04T03:08:31.441Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41209</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the implementations for convolution operators trigger a division by 0 if passed empty filter tensor arguments. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41209|2024-08-04T03:08:31.441Z</guid>
      <pubDate>Fri, 05 Nov 2021 21:45:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37682|2024-08-04T01:23:01.529Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37682</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37682|2024-08-04T01:23:01.529Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:45:12 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37664|2024-08-04T01:23:01.437Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37664</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `BoostedTreesSparseCalculateBestFeatureSplit`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) needs to validate that each value in `stats_summary_indices` is in range. We have patched the issue in GitHub commit e84c975313e8e8e38bb2ea118196369c45c51378. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37664|2024-08-04T01:23:01.437Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:25:23 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37636|2024-08-04T01:23:01.388Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37636</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseDenseCwiseDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L56) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit d9204be9f49520cdaaeb2541d1dc5187b23f31d9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37636|2024-08-04T01:23:01.388Z</guid>
      <pubDate>Thu, 12 Aug 2021 17:30:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37673|2024-08-04T01:23:01.441Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37673</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.MapStage`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L513) does not check that the `key` input is a valid non-empty tensor. We have patched the issue in GitHub commit d7de67733925de196ec8863a33445b73f9562d1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37673|2024-08-04T01:23:01.441Z</guid>
      <pubDate>Thu, 12 Aug 2021 22:55:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37659|2024-08-04T01:23:01.517Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37659</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all binary cwise operations that don't require broadcasting (e.g., gradients of binary cwise operations). The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/cwise_ops_common.h#L264) assumes that the two inputs have exactly the same number of elements but does not check that. Hence, when the eigen functor executes it triggers heap OOB reads and undefined behavior due to binding to nullptr. We have patched the issue in GitHub commit 93f428fd1768df147171ed674fee1fc5ab8309ec. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37659|2024-08-04T01:23:01.517Z</guid>
      <pubDate>Thu, 12 Aug 2021 20:25:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37643|2024-08-04T01:23:01.386Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37643</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. If a user does not provide a valid padding value to `tf.raw_ops.MatrixDiagPartOp`, then the code triggers a null pointer dereference (if input is empty) or produces invalid behavior, ignoring all values after the first. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L89) reads the first value from a tensor buffer without first checking that the tensor has values to read from. We have patched the issue in GitHub commit 482da92095c4d48f8784b1f00dda4f81c28d2988. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37643|2024-08-04T01:23:01.386Z</guid>
      <pubDate>Thu, 12 Aug 2021 18:10:21 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41222|2024-08-04T03:08:31.547Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41222</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41222|2024-08-04T03:08:31.547Z</guid>
      <pubDate>Fri, 05 Nov 2021 22:30:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41226|2024-08-04T03:08:31.504Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41226</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseBinCount` is vulnerable to a heap OOB access. This is because of missing validation between the elements of the `values` argument and the shape of the sparse output. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41226|2024-08-04T03:08:31.504Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:20:22 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-41212|2024-08-04T03:08:31.357Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-41212</link>
      <description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-41212|2024-08-04T03:08:31.357Z</guid>
      <pubDate>Fri, 05 Nov 2021 20:15:17 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2021-37645|2024-08-04T01:23:01.313Z -- tensorflow -- tensorflow
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2021-37645</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L126) uses the `axis` value as the size argument to `absl::InlinedVector` constructor. But, the constructor uses an unsigned type for the argument, so the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit 96f364a1ca3009f98980021c4b32be5fdcca33a1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, and TensorFlow 2.4.3, as these are also affected and still in supported range.</description>
      <guid isPermaLink="false">CVE-2021-37645|2024-08-04T01:23:01.313Z</guid>
      <pubDate>Thu, 12 Aug 2021 21:05:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2024-3660|2024-08-01T20:20:00.692Z -- tensorflow -- keras</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2024-3660</link>
      <description>A arbitrary code injection vulnerability in TensorFlow's Keras framework (&lt;2.13) allows attackers to execute arbitrary code with the same permissions as the application using a model that allow arbitrary code irrespective of the application.</description>
      <guid isPermaLink="false">CVE-2024-3660|2024-08-01T20:20:00.692Z</guid>
      <pubDate>Tue, 16 Apr 2024 20:09:26 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2023-33976|2024-08-01T20:14:02.779Z -- tensorflow -- tensorflow</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2023-33976</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. `array_ops.upper_bound` causes a segfault when not given a rank 2 tensor. The fix will be included in TensorFlow 2.13 and will also cherrypick this commit on TensorFlow 2.12.</description>
      <guid isPermaLink="false">CVE-2023-33976|2024-08-01T20:14:02.779Z</guid>
      <pubDate>Tue, 30 Jul 2024 19:27:14 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2024-3660|2024-07-29T19:38:15.693Z -- tensorflow -- keras</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2024-3660</link>
      <description>A arbitrary code injection vulnerability in TensorFlow's Keras framework (&lt;2.13) allows attackers to execute arbitrary code with the same permissions as the application using a model that allow arbitrary code irrespective of the application.</description>
      <guid isPermaLink="false">CVE-2024-3660|2024-07-29T19:38:15.693Z</guid>
      <pubDate>Tue, 16 Apr 2024 20:09:26 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2024-3660|2024-04-16T20:09:26.220Z -- tensorflow -- keras</title>
      <link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-3660</link>
      <description>A arbitrary code injection vulnerability in TensorFlow's Keras framework (&lt;2.13) allows attackers to execute arbitrary code with the same permissions as the application using a model that allow arbitrary code irrespective of the application.</description>
      <guid isPermaLink="false">CVE-2024-3660|2024-04-16T20:09:26.220Z</guid>
      <pubDate>Tue, 16 Apr 2024 20:09:26 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2023-33976|2024-07-30T19:27:14.532Z -- tensorflow -- tensorflow</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2023-33976</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. `array_ops.upper_bound` causes a segfault when not given a rank 2 tensor. The fix will be included in TensorFlow 2.13 and will also cherrypick this commit on TensorFlow 2.12.</description>
      <guid isPermaLink="false">CVE-2023-33976|2024-07-30T19:27:14.532Z</guid>
      <pubDate>Tue, 30 Jul 2024 19:27:14 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2023-33976|2024-08-02T15:54:14.208Z -- tensorflow -- tensorflow</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2023-33976</link>
      <description>TensorFlow is an end-to-end open source platform for machine learning. `array_ops.upper_bound` causes a segfault when not given a rank 2 tensor. The fix will be included in TensorFlow 2.13 and will also cherrypick this commit on TensorFlow 2.12.</description>
      <guid isPermaLink="false">CVE-2023-33976|2024-08-02T15:54:14.208Z</guid>
      <pubDate>Tue, 30 Jul 2024 19:27:14 +0000</pubDate>
    </item>
  </channel>
</rss>
