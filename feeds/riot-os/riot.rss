<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>CVE Feed for RIOT-OS -- RIOT</title><link>https://raw.githubusercontent.com/deepseas/cvelistV5monitor/main/feeds/riot-os/riot.rss</link><description>The latest CVEs for RIOT-OS -- RIOT</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><lastBuildDate>Fri, 24 May 2024 21:24:10 +0000</lastBuildDate><ttl>60</ttl><item><title>CVE-2024-32018|2024-05-01T06:14:03.199Z -- RIOT-OS -- RIOT
</title><link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-32018</link><description>RIOT is a real-time multi-threading operating system that supports a range of devices that are typically 8-bit, 16-bit and 32-bit microcontrollers. Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks. In detail, in the `nimble_scanlist_update()` function below, `len` is checked in an assertion and subsequently used in a call to `memcpy()`. If an attacker is able to provide a larger `len` value while assertions are compiled-out, they can write past the end of the fixed-length `e-&gt;ad` buffer. If the unchecked input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerability could range from denial of service to arbitrary code execution. This issue has not yet been patched. Users are advised to add manual `len` checking.</description><guid isPermaLink="false">CVE-2024-32018|2024-05-01T06:14:03.199Z</guid><pubDate>Wed, 01 May 2024 06:14:03 +0000</pubDate></item><item><title>CVE-2024-32017|2024-05-01T06:14:01.531Z -- RIOT-OS -- RIOT
</title><link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-32017</link><description>RIOT is a real-time multi-threading operating system that supports a range of devices that are typically 8-bit, 16-bit and 32-bit microcontrollers. The size check in the `gcoap_dns_server_proxy_get()` function contains a small typo that may lead to a buffer overflow in the subsequent `strcpy()`. In detail, the length of the `_uri` string is checked instead of the length of the `_proxy` string. The `_gcoap_forward_proxy_copy_options()` function does not implement an explicit size check before copying data to the `cep-&gt;req_etag` buffer that is `COAP_ETAG_LENGTH_MAX` bytes long. If an attacker can craft input so that `optlen` becomes larger than `COAP_ETAG_LENGTH_MAX`, they can cause a buffer overflow. If the input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerabilities could range from denial of service to arbitrary code execution. This issue has yet to be patched. Users are advised to add manual bounds checking.</description><guid isPermaLink="false">CVE-2024-32017|2024-05-01T06:14:01.531Z</guid><pubDate>Wed, 01 May 2024 06:14:01 +0000</pubDate></item><item><title>CVE-2024-31225|2024-05-01T06:13:58.610Z -- RIOT-OS -- RIOT
</title><link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-31225</link><description>RIOT is a real-time multi-threading operating system that supports a range of devices that are typically 8-bit, 16-bit and 32-bit microcontrollers. The `_on_rd_init()` function does not implement a size check before copying data to the `_result_buf` static buffer. If an attacker can craft a long enough payload, they could cause a buffer overflow. If the unchecked input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerability could range from denial of service to arbitrary code execution. This issue has yet to be patched. Users are advised to add manual bounds checking.</description><guid isPermaLink="false">CVE-2024-31225|2024-05-01T06:13:58.610Z</guid><pubDate>Wed, 01 May 2024 06:13:58 +0000</pubDate></item></channel></rss>