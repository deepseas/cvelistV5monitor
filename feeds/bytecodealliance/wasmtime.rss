<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>CVE Feed for bytecodealliance -- wasmtime</title>
    <link>https://raw.githubusercontent.com/deepseas/cvelistV5monitor/main/feeds/bytecodealliance/wasmtime.rss</link>
    <description>The latest CVEs for bytecodealliance -- wasmtime</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <lastBuildDate>Sat, 03 Aug 2024 19:19:33 +0000</lastBuildDate>
    <ttl>60</ttl>
    <item>
      <title>CVE-2022-39393|2024-08-03T12:07:42.224Z -- bytecodealliance -- wasmtime
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2022-39393</link>
      <description>Wasmtime is a standalone runtime for WebAssembly. Prior to version 2.0.2, there is a bug in Wasmtime's implementation of its pooling instance allocator where when a linear memory is reused for another instance the initial heap snapshot of the prior instance can be visible, erroneously to the next instance. This bug has been patched and users should upgrade to Wasmtime 2.0.2. Other mitigations include disabling the pooling allocator and disabling the `memory-init-cow`.</description>
      <guid isPermaLink="false">CVE-2022-39393|2024-08-03T12:07:42.224Z</guid>
      <pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2022-31146|2024-08-03T07:11:39.649Z -- bytecodealliance -- wasmtime
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2022-31146</link>
      <description>Wasmtime is a standalone runtime for WebAssembly. There is a bug in the Wasmtime's code generator, Cranelift, where functions using reference types may be incorrectly missing metadata required for runtime garbage collection. This means that if a GC happens at runtime then the GC pass will mistakenly think these functions do not have live references to GC'd values, reclaiming them and deallocating them. The function will then subsequently continue to use the values assuming they had not been GC'd, leading later to a use-after-free. This bug was introduced in the migration to the `regalloc2` register allocator that occurred in the Wasmtime 0.37.0 release on 2022-05-20. This bug has been patched and users should upgrade to Wasmtime version 0.38.2. Mitigations for this issue can be achieved by disabling the reference types proposal by passing `false` to `wasmtime::Config::wasm_reference_types` or downgrading to Wasmtime 0.36.0 or prior.</description>
      <guid isPermaLink="false">CVE-2022-31146|2024-08-03T07:11:39.649Z</guid>
      <pubDate>Wed, 20 Jul 2022 22:30:16 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2022-23636|2024-08-03T03:51:46.018Z -- bytecodealliance -- wasmtime
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2022-23636</link>
      <description>Wasmtime is an open source runtime for WebAssembly &amp; WASI. Prior to versions 0.34.1 and 0.33.1, there exists a bug in the pooling instance allocator in Wasmtime's runtime where a failure to instantiate an instance for a module that defines an `externref` global will result in an invalid drop of a `VMExternRef` via an uninitialized pointer. A number of conditions listed in the GitHub Security Advisory must be true in order for an instance to be vulnerable to this issue. Maintainers believe that the effective impact of this bug is relatively small because the usage of `externref` is still uncommon and without a resource limiter configured on the `Store`, which is not the default configuration, it is only possible to trigger the bug from an error returned by `mprotect` or `VirtualAlloc`. Note that on Linux with the `uffd` feature enabled, it is only possible to trigger the bug from a resource limiter as the call to `mprotect` is skipped. The bug has been fixed in 0.34.1 and 0.33.1 and users are encouraged to upgrade as soon as possible. If it is not possible to upgrade to version 0.34.1 or 0.33.1 of the `wasmtime` crate, it is recommend that support for the reference types proposal be disabled by passing `false` to `Config::wasm_reference_types`. Doing so will prevent modules that use `externref` from being loaded entirely.</description>
      <guid isPermaLink="false">CVE-2022-23636|2024-08-03T03:51:46.018Z</guid>
      <pubDate>Wed, 16 Feb 2022 22:00:10 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2022-39392|2024-08-03T12:07:41.880Z -- bytecodealliance -- wasmtime
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2022-39392</link>
      <description>Wasmtime is a standalone runtime for WebAssembly. Prior to version 2.0.2, there is a bug in Wasmtime's implementation of its pooling instance allocator when the allocator is configured to give WebAssembly instances a maximum of zero pages of memory. In this configuration, the virtual memory mapping for WebAssembly memories did not meet the compiler-required configuration requirements for safely executing WebAssembly modules. Wasmtime's default settings require virtual memory page faults to indicate that wasm reads/writes are out-of-bounds, but the pooling allocator's configuration would not create an appropriate virtual memory mapping for this meaning out of bounds reads/writes can successfully read/write memory unrelated to the wasm sandbox within range of the base address of the memory mapping created by the pooling allocator. This bug is not applicable with the default settings of the `wasmtime` crate. This bug can only be triggered by setting `InstanceLimits::memory_pages` to zero. This is expected to be a very rare configuration since this means that wasm modules cannot allocate any pages of linear memory. All wasm modules produced by all current toolchains are highly likely to use linear memory, so it's expected to be unlikely that this configuration is set to zero by any production embedding of Wasmtime. This bug has been patched and users should upgrade to Wasmtime 2.0.2. This bug can be worked around by increasing the `memory_pages` allotment when configuring the pooling allocator to a value greater than zero. If an embedding wishes to still prevent memory from actually being used then the `Store::limiter` method can be used to dynamically disallow growth of memory beyond 0 bytes large. Note that the default `memory_pages` value is greater than zero.</description>
      <guid isPermaLink="false">CVE-2022-39392|2024-08-03T12:07:41.880Z</guid>
      <pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2022-39394|2024-08-03T12:07:41.252Z -- bytecodealliance -- wasmtime
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2022-39394</link>
      <description>Wasmtime is a standalone runtime for WebAssembly. Prior to version 2.0.2, there is a bug in Wasmtime's C API implementation where the definition of the `wasmtime_trap_code` does not match its declared signature in the `wasmtime/trap.h` header file. This discrepancy causes the function implementation to perform a 4-byte write into a 1-byte buffer provided by the caller. This can lead to three zero bytes being written beyond the 1-byte location provided by the caller. This bug has been patched and users should upgrade to Wasmtime 2.0.2. This bug can be worked around by providing a 4-byte buffer casted to a 1-byte buffer when calling `wasmtime_trap_code`. Users of the `wasmtime` crate are not affected by this issue, only users of the C API function `wasmtime_trap_code` are affected.</description>
      <guid isPermaLink="false">CVE-2022-39394|2024-08-03T12:07:41.252Z</guid>
      <pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2022-31169|2024-08-03T07:11:39.608Z -- bytecodealliance -- wasmtime
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2022-31169</link>
      <description>Wasmtime is a standalone runtime for WebAssembly. There is a bug in Wasmtime's code generator, Cranelift, for AArch64 targets where constant divisors can result in incorrect division results at runtime. This affects Wasmtime prior to version 0.38.2 and Cranelift prior to 0.85.2. This issue only affects the AArch64 platform. Other platforms are not affected. The translation rules for constants did not take into account whether sign or zero-extension should happen which resulted in an incorrect value being placed into a register when a division was encountered. The impact of this bug is that programs executing within the WebAssembly sandbox would not behave according to the WebAssembly specification. This means that it is hypothetically possible for execution within the sandbox to go awry and WebAssembly programs could produce unexpected results. This should not impact hosts executing WebAssembly but does affect the correctness of guest programs. This bug has been patched in Wasmtime version 0.38.2 and cranelift-codegen 0.85.2. There are no known workarounds.</description>
      <guid isPermaLink="false">CVE-2022-31169|2024-08-03T07:11:39.608Z</guid>
      <pubDate>Thu, 21 Jul 2022 13:50:11 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2022-31104|2024-08-03T07:11:39.222Z -- bytecodealliance -- wasmtime
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2022-31104</link>
      <description>Wasmtime is a standalone runtime for WebAssembly. In affected versions wasmtime's implementation of the SIMD proposal for WebAssembly on x86_64 contained two distinct bugs in the instruction lowerings implemented in Cranelift. The aarch64 implementation of the simd proposal is not affected. The bugs were presented in the `i8x16.swizzle` and `select` WebAssembly instructions. The `select` instruction is only affected when the inputs are of `v128` type. The correspondingly affected Cranelift instructions were `swizzle` and `select`. The `swizzle` instruction lowering in Cranelift erroneously overwrote the mask input register which could corrupt a constant value, for example. This means that future uses of the same constant may see a different value than the constant itself. The `select` instruction lowering in Cranelift wasn't correctly implemented for vector types that are 128-bits wide. When the condition was 0 the wrong instruction was used to move the correct input to the output of the instruction meaning that only the low 32 bits were moved and the upper 96 bits of the result were left as whatever the register previously contained (instead of the input being moved from). The `select` instruction worked correctly if the condition was nonzero, however. This bug in Wasmtime's implementation of these instructions on x86_64 represents an incorrect implementation of the specified semantics of these instructions according to the WebAssembly specification. The impact of this is benign for hosts running WebAssembly but represents possible vulnerabilities within the execution of a guest program. For example a WebAssembly program could take unintended branches or materialize incorrect values internally which runs the risk of exposing the program itself to other related vulnerabilities which can occur from miscompilations. We have released Wasmtime 0.38.1 and cranelift-codegen (and other associated cranelift crates) 0.85.1 which contain the corrected implementations of these two instructions in Cranelift. If upgrading is not an option for you at this time, you can avoid the vulnerability by disabling the Wasm simd proposal. Additionally the bug is only present on x86_64 hosts. Other aarch64 hosts are not affected. Note that s390x hosts don't yet implement the simd proposal and are not affected.</description>
      <guid isPermaLink="false">CVE-2022-31104|2024-08-03T07:11:39.222Z</guid>
      <pubDate>Mon, 27 Jun 2022 23:20:13 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2022-24791|2024-08-03T04:20:50.505Z -- bytecodealliance -- wasmtime
</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2022-24791</link>
      <description>Wasmtime is a standalone JIT-style runtime for WebAssembly, using Cranelift. There is a use after free vulnerability in Wasmtime when both running Wasm that uses externrefs and enabling epoch interruption in Wasmtime. If you are not explicitly enabling epoch interruption (it is disabled by default) then you are not affected. If you are explicitly disabling the Wasm reference types proposal (it is enabled by default) then you are also not affected. The use after free is caused by Cranelift failing to emit stack maps when there are safepoints inside cold blocks. Cold blocks occur when epoch interruption is enabled. Cold blocks are emitted at the end of compiled functions, and change the order blocks are emitted versus defined. This reordering accidentally caused Cranelift to skip emitting some stack maps because it expected to emit the stack maps in block definition order, rather than block emission order. When Wasmtime would eventually collect garbage, it would fail to find live references on the stack because of the missing stack maps, think that they were unreferenced garbage, and therefore reclaim them. Then after the collection ended, the Wasm code could use the reclaimed-too-early references, which is a use after free. Patches have been released in versions 0.34.2 and 0.35.2, which fix the vulnerability. All Wasmtime users are recommended to upgrade to these patched versions. If upgrading is not an option for you at this time, you can avoid the vulnerability by either: disabling the Wasm reference types proposal, config.wasm_reference_types(false); or by disabling epoch interruption if you were previously enabling it. config.epoch_interruption(false).</description>
      <guid isPermaLink="false">CVE-2022-24791|2024-08-03T04:20:50.505Z</guid>
      <pubDate>Thu, 31 Mar 2022 23:00:15 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2024-30266|2024-08-02T01:32:07.072Z -- bytecodealliance -- wasmtime</title>
      <link>https://www.cve.org/CVERecord?id=CVE-2024-30266</link>
      <description>wasmtime is a runtime for WebAssembly. The 19.0.0 release of Wasmtime contains a regression introduced during its development which can lead to a guest WebAssembly module causing a panic in the host runtime. A valid WebAssembly module, when executed at runtime, may cause this panic. This vulnerability has been patched in version 19.0.1.</description>
      <guid isPermaLink="false">CVE-2024-30266|2024-08-02T01:32:07.072Z</guid>
      <pubDate>Thu, 04 Apr 2024 15:42:00 +0000</pubDate>
    </item>
    <item>
      <title>CVE-2024-30266|2024-06-04T17:38:20.190Z -- bytecodealliance -- wasmtime</title>
      <link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-30266</link>
      <description>wasmtime is a runtime for WebAssembly. The 19.0.0 release of Wasmtime contains a regression introduced during its development which can lead to a guest WebAssembly module causing a panic in the host runtime. A valid WebAssembly module, when executed at runtime, may cause this panic. This vulnerability has been patched in version 19.0.1.</description>
      <guid isPermaLink="false">CVE-2024-30266|2024-06-04T17:38:20.190Z</guid>
      <pubDate>Thu, 04 Apr 2024 15:42:00 +0000</pubDate>
    </item>
  </channel>
</rss>
